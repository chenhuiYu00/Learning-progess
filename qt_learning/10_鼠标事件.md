# 鼠标事件

> 鼠标事件会根据鼠标的状态触发

![2022-08-22 10-47-00 的屏幕截图](10_鼠标事件.assets/2022-08-22 10-47-00 的屏幕截图.png)

<img src="10_鼠标事件.assets/2022-08-22 10-16-15 的屏幕截图.png" alt="2022-08-22 10-16-15 的屏幕截图" style="zoom: 80%;" />

 ![2022-08-22 10-04-09 的屏幕截图](10_鼠标事件.assets/2022-08-22 10-04-09 的屏幕截图.png)

```c++
主要使用
    leaveEvent(QEvent*)//离开触发
    enterEvent(QEvent*)//进入触发 
    mouseMoveEvent(QEvent*) //是过程事件，随鼠标实时更新
通过重载这些函数来干想要的事
    
leaveEvent(QEvent*)，enterEvent(QEvent*)直接重载
     
只有点按鼠标才会触发mouseMoveEvent，如果需要在鼠标移动时就可以使用 mouseMoveEvent(QEvent*)，在控件自定义中设置来开启鼠标监控
    setMouseTracking(true);//false时只有点按鼠标才会触发mouseMoveEvent
```

因为有leaveEvent()事件，所以鼠标移动到按钮，按钮变化什么的不需要根据是否移动到其他控件时触发returnBtn()来恢复，直接重载leaveEvent()恢复就行了



**设置边框**

![2022-08-22 10-12-25 的屏幕截图](10_鼠标事件.assets/2022-08-22 10-12-25 的屏幕截图.png)





## QMouseEvent

> 鼠标事件传进去的类，需要`#include<QMouseEvent>`, 有以下

![2022-08-22 10-21-16 的屏幕截图](10_鼠标事件.assets/2022-08-22 10-21-16 的屏幕截图.png)

> globalX()显示的是在整个屏幕的坐标
>
> x()显示的是控件内的坐标



> button()返回按键类型枚举值
>
> buttons()返回联合值，包含左右中

![2022-08-22 10-28-20 的屏幕截图](10_鼠标事件.assets/2022-08-22 10-28-20 的屏幕截图.png)

```c++
ev->button() == Qt::LeftButton 
ev->buttons() & Qt::LeftButton  //相当于从触发的按键中过滤出是否有触发左击，左右中的二进制分别为001 010 100，所以很精妙地利用了按位与  
```

