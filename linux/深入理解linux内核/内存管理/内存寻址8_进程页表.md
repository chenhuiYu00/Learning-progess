# 进程页表

> 进程的线性地址空间被分为两部分:
>
> - 0x00000000到0xbfffffff的线性地址，运行在内核态和用户态的进程都可以使用
> - 0xc0000000到0xffffffff的线性地址吗，只有内核态的进程才可以寻址

一般情况下，进程运行在用户态时产生的线性地址小于0xc0000000，运行在内核态时产生的地址大于等于0xc00000000.

特定情况下，内核为了检索和存放数据也会访问用户态线性地址空间。



**宏PAGE_OFFSET**

宏``PAGE_OFFSET``产生的值是0xc0000000，这就是进程在线性地址空间的偏移量，也是内核生存空间的开始处。



**页全局目录**

页全局目录第一表项映射的线性地址小于0xc0000000(**物理地址扩展PAE**启用前是前768项，启用后是前3项)，具体大小依赖具体进程。





# 内核页表

> 内核维持着自己使用的页表，驻留在主内核也全局目录中。系统初始化后，这组页表从未被任何进程或内核进程直接使用；
>
> 确切而言，主内核页全局目录的最高目录项部分作为最高参考模型，为系统中的每个普通进程对应的页全局目录提供参考。第八章“非连续内存区的线性地址”中会阐述内核怎样确保对前者的修改能传递到后者上。

现在我们会开始了解内核如何初始化自己的页表。通常有两个阶段：

- **内核创建一个有限的地址空间**，包括内核的代码段，数据段，初始页表和用于存放动态数据结构的共128KB大小的空间。

```c
这是一个最小限度的空间，仅能够将内核装入RAM和对其初始化的核心数据结构。
```

- **内核充分使用剩余的RAM并适当建立页表**



==注意：内核映像刚装入内存后，CPU仍然运行于实模式，所以分页功能还未启用==   





## 临时内核页表

> [参考](https://blog.csdn.net/G_linuxer_/article/details/50981789)
>
> 临时页全局目录是在编译的过程中静态地初始化的，这个阶段PAE并未激活。
>
> 临时页全局目录放在swapper_pg_dir变量中。临时页表在pg0变量处开始存放，紧跟在内核未初始化的数据段(_end符号)后面。我们假设内核使用的段，临时页表和128kb的内存范围能容纳与RAM前8MB空间里。为了映射RAM前8MB的空间，需要使用两个页表。

分页的第一个阶段，它的目标是在实模式和保护模式下都可以**通过与物理地址相同的线性地址或其他线性地址对8MB进行寻址，并做一个由实模式向保护模式的转换 ** 。因此内核创建一个映射，把从0x00000000到0x007ffff的线性地址(`与物理地址相同`)和从0xc0000000到0xc07fffff的线性地址(`0xc0000000`)映射到从0x00000000到0x007fffff的物理地址。





> 内核通过把swapper_pg_dir所有项都填充为0来创建期望的映射（1024项），不过，0、1、0x300（十进制的第768项）和 0x301(十进制的第769项)这四项除外；后两项包含了从0xc0000000到0xc07fffff 间的，也就是从0xc0000000开始的8MB所有线性地址。0、1、0x300和0x301按以下方式初始化：

- 0项和0x300项的地址字段置为pg0的物理地址，而1项和0x301项的地址字段置为紧随pg0后的页框的物理地址。
- 把这四个项中的Present,、Read/Write和 User/Supervisor标志置位。
- 把这四个项中的Accessed 、Dirty、PCD、PWD和Page Size标志清0。

 



> 当建立好临时内核页表后，我们会马上使用这个映射，因为初始化期间，我们需要进入保护模式来初始化内核的各个数据结构。在初始化期间，由汇编语言函数startup_32()来启用分页单元：通过向cr3控制寄存器装入swapper_pg_dir的地址及设置cr0控制寄存器的PG 标志来达到这一目的。下面是等价的代码片段：

```c
movl $swapper_pg_dir-0xc0000000,%eax
movl %eax,%cr3         /*设置页表指针…*/…
movl %cr0,%eax
orl  $0x80000000,%eax
movl %eax,%cr0         /*……设置分页（PG）位*/
```



接下来就是第二阶段。







## 最终内核页表

> 建立好临时内核页表后，我们可以离开实模式了，之后我们将利用80x86体系CPU的保护模式实现内核及各个进程的虚拟化存储管理。不过， 这个内核临时页表只有8MB的映射，只是用来对初始化阶段的内核来进行寻址，还不能满足对整个内存管理的要求。那么我们进行了第二阶段，**建立内核最终页表**。在 32位80X86体系中，内核最终页表的建立需要根据RAM的实际大小来进行。



### RAM小于896MB时

```c
或许我们可以先想一下为啥要设定以896MB为界限对一个内核最终页表进行处理：
    (P76)//线性地址的最高128MB被留给做映射去使用，这时映射RAM的所剩空间就是1GB - 128MB = 896MB
```



> 由内核页表所提供的最终映射必须把从0xc0000000开始的线性地址转化为从0开始的物理地址。宏``__pa``用于把从PAGE_OFFSET开始 的线性地址转换成相应的物理地址，而宏``__va``做相反的转化。
>
> 主内核页全局目录仍然保存在swapper_pg_dir变量中。它由 paging_init() 函数初始化。该函数进行如下操作：

- 调用``pagetable_init()``适当地建立页表项。
- 把`swapper_pg_dir`的物理地址写入cr3控制寄存器中。
- 如果CPU支持PAE并且如果内核编译时支持PAE，将cr4控制寄存器的PAE标志置位。
- 调用`flush_tlb_all()`使TLB的所有项无效。



``pagetable_init()``执行的操作既依赖于现有RAM容量，也依赖于CPU模型。对于896MB的情况，32位物理地址是足够用于寻址的，所以没有必要激活物理地址扩展机制(PAE）