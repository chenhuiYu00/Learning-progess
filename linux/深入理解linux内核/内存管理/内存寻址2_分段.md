# 分段

> 文档1中的由逻辑地址中的段选择符获取段描述符再获取物理地址的方式即分段单元。
>
> 分段与分页都可以划分物理地址空间。分段可以给一个进程分配不同线性地址空间；分页可以把同一线性地址空间映射到不同的物理空间。

Linux更倾向于分页

- 分页能够使使用同一段寄存器值的多个进程共享同一组线性地址，这样方便于内存管理。
- 部分体系结构对分段的支持有限(例如RISC)，使用分页符合Linux的移植性目标。



2.6版的Linux在80x86结构下才需要分段。



## 四种主要的Linux段描述符

> 运行在内核态和用户态的所有Linux进程各自使用**一对相同的段**来对指令和数据寻址。即用户代码段，用户数据段；内核代码段，内核数据段

| 段         | BASE       | G    | LIMIT   | S    | TYPE | DPL  | D/B  | P    |
| ---------- | ---------- | ---- | ------- | ---- | ---- | ---- | ---- | ---- |
| 用户代码段 | 0x00000000 | 1    | 0xfffff | 1    | 10   | 3    | 1    | 1    |
| 用户数据段 | 0x00000000 | 1    | 0xfffff | 1    | 2    | 3    | 1    | 1    |
| 内核代码段 | 0x00000000 | 1    | 0xfffff | 1    | 10   | 0    | 1    | 1    |
| 内核数据段 | 0x00000000 | 1    | 0xfffff | 1    | 2    | 0    | 1    | 1    |



> 四个段各对应一个宏,我们在对用户，内核段进行寻址时，内核只需把相应宏产生的值装载进相应CS/DS段寄存器里。

- 用户代码段： __USER_CS
- 用户数据段：__USER_DS
- 内核代码段：__KERNEL_CS
- 内核数据段：__KERNEL_DS



### 寻址特点

1. 与段相关的线性地址，从**0开始到2^32-1**的寻址限长，这之间都可以被内核态和用户态访问，他们的进程也能使用相同的逻辑地址。
2. 从上表我们可以看到所有段由0x00000000开始，因此Linux的**逻辑地址与线性地址一致**

```c 
线性地址等于段选择符指定的段描述符的基址加上偏移量，因为基址是0x0000000，那么偏移量就等于了线性地址。
```

3. 在DPL值中我们看到了以0、3区别用户态，内核态。它由逻辑地址中的段选择符的RPL字段指定。

​		因此，当**特权级改变**时，一些段寄存器就要改变相应内容。

```c
例如ds数据段寄存器，根据CPL来确认自己存放内核数据段还是用户数据段。ss栈段寄存器，根据CPL来确认自己存放内核数据段中的内核栈还是用户数据段的用户栈。总之，Linux会确保寄存器储存正确的指向的段选择符。
```

4. 对指向指令或者数据结构的指针进行保存时，Linux也就不用为其逻辑地址设置段选择符，因为相应的的段选择符已经被宏__KERNEL_CS定义并装载进cs寄存器里。内核调用函数会执行一条call汇编指令，它只需要指定一个偏移量。

```c
在内核态执行的段只有一种，即代码段，它被宏__KERNEL_CS定义。
```

